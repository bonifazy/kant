  update/ -- пакет для парсинга, хранения и синхронизации данных с сайта www.kant.ru категории товаров 'беговая обувь'.

  В settings.py находятся ссылки для парсинга продукта поиска: BRANDS_URLS. С помощью метода Main.update_products_table
формируется базовый каркас описания каждого товара в таблицу 'products'. Дальнейшая работа по проверке динамики
ценообразования и аналитике продаж (изменение количества товара каждого размера), а также обновлению этих параметров,
идет уже с синхронизацией этой таблицы (основные графы работы: 'code'-- уникальный код (id) товара, 'url'-- прямая
ссылка на карточку этого товара). По прямой ссылке товара в последующий раз можно отслеживать динамику изменения цены:
Main.update_prices_table() выгружает каждую новую измененную стоимость товара в таблицу 'prices', не затирая предыдущее
значение стоимости, повышая значение колонки 'рейтинг' этого товара (этого кода товара). Таким образом, актуальная цена
находится в строке с максимальным рейтингом, среди всех строк стоимостей конкретного товара.

  'Рейтинг': значение- абстракция уровня обновления и доступности товара.
Изначально, значение в settings.RATING: 4. При этом значении, в таблице 'products' находятся товары в наличии.
Значение 1 для товаров, которых уже нет в наличии (а было все норм: 4).
Значение 2 для вновь появившихся товаров, которых не было в наличии (у которых было значение 1).
Значение > 4 для товаров в таблицах 'prices' и 'instock_nagornaya', у которых либо обновилась стоимость, либо обновился
остаток по конкретному товару конкретного размера. Соответственно, актуальная динамика стоимости и продажи (смены
количества размеров на складе) имеет максимальный рейтинг у данного товара.
В таблице 'products' графа 'rating' изменяется между значениями: 4, 1 или 2, перезаписывая эти значения, не создавая
новые строки.
В таблицах 'prices' и 'instock_nagornaya', 'rating' изменяется с 4 на 1 и с 1 на 4, каждый раз создавая новые строки с
обновленным рейтингом нового состояния продукта.

  'main.py'-- точка входа проекта.
С помощью этого модуля при пустой базе данных 'db.sqlite3' создаются записи в таблицах. Если данные уже внесены,
последующий запуск main.py обновит данные при непустых соответствующих таблицах:
  Таблица 'products': Общая карточки товара, его наименование, описание, характеристика товара, дата внесения этой
информации и текущий рейтинг, информирующий об актуальности нахождения товара в наличии и в продаже на момент
последнего запуска программы (обновления таблиц) (описание рейтинга см выше, параграф 'Рейтинг').
Таблица формируется за счет запуска метода Main.update_products_table()
В проекте реальзована функция частичной загрузки и частичной проверки данных по конкретному бренду, не затрагивая
консистентность данных остальной части базы данных, что является удобным для поддержания, изменения, дополнения и
тестирования проекта на этапе разработки (см далее параграф 'Main.brand')

  Метод Main.update_products_table() сначала парсит главные ссылки общей группы товаров (либо/ и ссылки на товары
конкретных брендов этой же категории), для получения индивидуальной ссылки на каждый товар путем
внутреннего вызова Parser.parse_main()
    Параметры: urls-- список ссылок на товары, для нахождения прямых ссылок на каждый конкретный товар;
               finish-- максимальное число листания пагинатора, от 1 до 25стр, обычно хватает. При дублировании данных,
        парсер понимает прием ссылок- дублей, затем отключается (не используя след страницы пагинации в связи
        с нецелесообразностью дальнейшего парсинга), формируя уникальный список прямых ссылок на товар.
    Вывод: список прямых ссылок на товар.
Затем, по каждой индивидуальной ссылке, загружается карточка товара с описанием и дополнительными характеристиками
товара методом Parser.parse_details()
    Параметры: urls-- список прямых ссылок на каждый конктретный товар.
    Вывод: код товара, наименование и полная характеристика продукта, время создания, рейтинг (см выше, 'рейтинг').
При каждом последующем запуске update_products_table(), добавляется новый товар, либо ничего не меняется, если нового
нет, либо изменяется только рейтинг, с 4 на 1 (для выбывших товаров), либо с 1 на 2 (для появившихся снова),
не изменяя количества записей, в целом.

  Метод Main.update_prices_table() испульзуя 'url' каждого товара из 'products', парсит карточку товара, использует
только стоимость. Если стоимость обновилась, в таблицу 'prices' записывается новая строка с кодом товара, стоимостью,
временем обновления и новым рейтингом (старый рейт+ 1). Актуальная стоимость товара всегда доступна как строка по коду
с максимальным рейтингом. Если товара нет в наличии, стоимость меняется на 0 руб, рейтинг все так же увеличивается.
Внутри используется Parser.parse_price()
    Параметры: codes_urls-- список пар кодов и ссылок для парсинга
    Вывод: типа codes_prices-- т.е те же коды, но уже со стоимостью товара

  Метод Main.update_instock_table() загружает из settings.AVAILABLE по коду товара из 'products', парсит небольшой html,
находит, сравнивает количество товара в наличии по каждому своему размеру. Если наличие изменилось (появился новый
размер, по бывшему размеру увеличилось/ уменьшилось количество товара, либо данный размер полностью выбывает
из магазина), в таблицу 'instock_nagornaya' записывается новое состояние размера товара: код товара, его размер,
количество товара в этом размере, время обновления, и рейтинг (см ранее, 'Рейтинг'). Каждая новая запись увеличивает
значение рейтинга.
Внутри используется Parser.parse_available()
    Параметры: codes-- пары кодов и уникальных кодов с их же url для парсинга размеров и наличия
    Вывод: список состояния наличия: код, размер, наличие по нему, время обновления, рейтинг

  'Main.brand' -- обертка property для тестирования и дополнения новой функциональности за счет работы не со всей базой
данных, а только с ее частью (определенного бренда), не затрагивая функциональность и консистентность данных
остальной части БД.
Название бренда можно задавать при инициализации, например:
    page = Main('Adidas') или page = Main(brand='Adidas')
Также можно определить бренд позднее, уже в атрибуте класса:
    page = Main()
    page.brand = 'Adidas'
В отличие от page = Main() без присвоения классу бренда, когда программа работает со всей бд, проверяя и синхронизируя
всю базу, вызов с присвоением бренда page = Main('Adidas') будет работать с таблицами только с этим брендом.

'Main.manager()' -- Уже настроенная точка входа, которую можно запускать из командной строки с параметрами, к примеру:
    (env) laptop:update user$ python main.py products
        Вызов запустит проверку синхронизации www.kant.ru с таблицей 'products' базы данных, рекомендуется запускать
        1 раз в день, проверка наличия и отсутствия товара.

    (env) laptop:update user$ python main.py prices
        -- запускает проверку, синхронизирует kant.ru с таблицей 'prices',
    рекомендуется запускать 1- 2 раза  день, динамика стоимости товара (обновление обычно, в 10:00, либо в 12:00,
    UTC +3 (Moscow))

    (env) laptop:update user$ python main.py instock
        -- запускает проверку, синхронизирует kant.ru с таблицей 'instock_nagornaya', рекомендуемая частота обновления:
        2- 4 раза в день, синхронизация и аналитика продаж: проверка разницы остатков товара по их размерам

    (env) laptop:update user$ python main.py products prices instock
    -- запускает проверку, синхронизирует kant.ru со всеми таблицами сразу

'update.__init__.py' Папка- пакет. Соотв, можно использовать весь проект, как отдельный стыковочный
    микросервис- парсер kant.ru в структуре своего django- приложения или telegram- бота для визуализации и
    анализа полученных данных.

* В ближайшее время добавится загрузка и обновление всех магазинов сети в Москве (4 филиала), по умолчанию доступна
синхронизация магазина 'Нагорная'. Идет тестирование всех филиалов.
* Чуть позже добавится сериализатор выгрузки карточек в 'InSales' и 'МойСклад' (scv, xml, xls) для маркетплейсов,
конкурентов и оптовых партнеров kant.ru
* Актуальная версия будет доступна в 'master' ветке проекта.
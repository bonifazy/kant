  kant/ -- пакет для парсинга, хранения и синхронизации данных спортивного магазина "Кант", сайта www.kant.ru
категории товаров 'беговая обувь' 4 оффлайн магазинов в г. Москва.

  В settings.BRANDS_URLS находятся ссылки для парсинга продуктов. С помощью метода Main.update_products_table()
формируется базовый каркас описания каждого товара в таблицу 'products'. Дальнейшая работа проверки ценообразования и
актуальность остатков размеров каждой модели, а также обновлению этих параметров, идет с синхронизацией
таблицы 'products'. Основные графы работы: 'code'-- уникальный код (id) товара, 'url'-- прямая
ссылка на карточку этого товара. По найденной прямой ссылке 'url' открывается полная карточка товара.
Main.update_prices_table() выгружает каждую новую измененную стоимость товара в таблицу 'prices', не затирая предыдущее
значение стоимости, а повышая значение колонки 'рейтинг' этого товара (этого кода товара). Таким образом, актуальная
стоимость находится в строке с максимальным рейтингом, среди всех строк стоимостей конкретного товара.

  'Рейтинг': значение- абстракция уровня обновления и доступности товара.
Изначально, значение в settings.RATING: 1. При этом значении в таблице 'products' находятся только товары в наличии.
Это же значения записывается, как начальное в таблицах 'prices' и во всех 'instock_...'- таблицах.
Значение 0 для товаров, которых уже нет в наличии (если было обычное состояние: 1).
Значение > 1 товаров в таблицах 'prices' и 'instock_nagornaya', у которых либо обновилась стоимость, либо обновился
остаток по конкретному товару конкретного размера. Соответственно, строка с актуальной стоимостью и состоянием склада
(смена количества штук по каждому размеру товара на складе), всегда имеет максимальный рейтинг у данного товара.
В таблице 'products' графа 'rating' изменяется между значениями: 1 и 0, перезаписывая эти значения, не создавая
новые строки.
В таблицах 'prices' и всех 'instock_...' таблицах, 'rating' изменяется от 1 и далее +1, каждый раз создавая
новые строки с обновленным (увеличенным на 1) рейтингом нового состояния продукта, в зависимости от ситуации по
актуальному наличию конкретного остатка размера продукта.

  'main.py'-- точка входа проекта.
С помощью этого модуля при пустой базе данных 'db.sqlite3' создаются записи в 'products', 'prices',
'instock_...'- таблицах. Если данные уже внесены, последующий запуск manager(True, True, True) обновит данные
при непустых соответствующих таблицах.
  Таблица 'products': Общая карточка товара, его наименование, описание, характеристика товара, дата внесения этой
информации и текущий рейтинг, информирующий об актуальности нахождения товара в наличии и в продаже на момент
последнего запуска программы (описание рейтинга см выше, параграф 'Рейтинг').
Таблица формируется за счет запуска метода Main.update_products_table()
В проекте реальзована функция частичной загрузки и частичной проверки данных по конкретному бренду, не затрагивая
консистентность данных остальной части базы данных, что является удобным для поддержания, изменения, дополнения и
тестирования проекта на этапе разработки (см далее параграф 'Main.brand')

  Метод Main.update_products_table() сначала парсит главные ссылки общей группы товаров (либо/ и ссылки на товары
конкретных брендов этой же категории (подробнее settings.BRANDS_URLS)), для получения индивидуальной ссылки на каждый
товар путем внутреннего вызова Parser.parse_main()
    Параметры: urls-- список ссылок на товары, для нахождения прямых ссылок на каждый конкретный товар;
               finish-- максимальное число листания пагинатора, от 1 до 25стр, обычно хватает. При дублировании данных,
        парсер понимает прием ссылок- дублей, отключается, не используя следующие страницы пагинации в связи
        с нецелесообразностью дальнейшего парсинга, формируя уникальный список прямых ссылок на товар;
    Вывод: список прямых ссылок на товар;
Затем, по каждой индивидуальной ссылке загружается карточка товара с описанием и дополнительными характеристиками
товара методом Parser.parse_details()
    Параметры: urls-- список прямых ссылок на каждый конктретный товар.
    Вывод: код товара, наименование и полная характеристика продукта, время создания, рейтинг (см выше, 'рейтинг').
При каждом последующем запуске update_products_table(), добавляется новый товар, либо ничего не меняется, если нового
нет, либо изменяется только рейтинг, с 4 на 1 (для выбывших товаров), с 1 на 4, если товар снова стал в наличии,
не изменяя количества записей, в целом.

  Метод Main.update_prices_table() испульзуя 'url' каждого товара из 'products', парсит карточку товара, использует
только стоимость. Если стоимость обновилась, в таблицу 'prices' записывается новая строка с кодом товара, стоимостью,
временем обновления и новым рейтингом (старый рейт+ 1). Актуальная стоимость товара всегда доступна, как строка по коду
с максимальным рейтингом. Если товара нет в наличии, стоимость меняется на 0 руб, рейтинг все так же увеличивается.
Внутри используется Parser.parse_price()
    Параметры: codes_urls-- список пар кодов и ссылок для парсинга;
    Вывод: типа codes_prices-- т.е те же коды, но уже со стоимостью товара;

  Метод Main.update_instock_table() загружает из settings.AVAILABLE по коду товара из 'products', парсит небольшой
(по объему DOM) html, находит, сравнивает количество товара в наличии по каждому размеру. Если наличие изменилось
(появился новый размер, по бывшему размеру увеличилось/ уменьшилось количество товара, либо данный размер полностью
выбыл из магазина), в эту рабочую таблицу 'instock_...' записывается новое состояние размера товара: код товара,
его размер, количество товара в этом размере, время обновления и рейтинг (см ранее, 'Рейтинг'). Каждая новая запись
увеличивает значение рейтинга.
Внутри используется Parser.parse_available()
    Параметры: codes-- пары кодов и уникальных кодов с их же url для парсинга размеров и наличия;
    Вывод: список состояния наличия: код, размер, наличие по нему, время обновления, рейтинг;

  'Main.brand' -- обертка property для тестирования и дополнения новой функциональности за счет работы не со всей базой
данных, а только с ее частью (определенного бренда), не затрагивая функциональность и консистентность данных
остальной части БД.
Название бренда можно задавать при инициализации, например:
    page = Main('Adidas') или page = Main(brand='Adidas')
Также можно определить бренд позднее, уже в атрибуте класса, перед вызовом методов обновления таблиц:
    page = Main()
    page.brand = 'Adidas'
В отличие от page = Main() без присвоения классу атрибута- бренда, когда программа работает со всей бд, проверяя и
синхронизируя всю базу, вызов с присвоением бренда page = Main('Adidas') работает с таблицами только этого бренда.

  'Main.manager()' -- Уже настроенная точка входа, которую можно запускать из командной строки с параметрами, к примеру:
    (env) laptop:kant user$ ./main.py products
        Вызов запустит проверку синхронизации www.kant.ru с таблицей 'products' базы данных, рекомендуется запускать
        1 раз в день, проверка наличия и отсутствия товара.

    (env) laptop:kant user$ ./main.py prices
        -- запускает проверку, синхронизируя kant.ru с таблицей 'prices';
    рекомендуется запускать 1- 2 раза  день, динамика стоимости товара (обновление, обычно, в 10:00 или в 12:00,
    UTC +3 (Moscow))

    (env) laptop:kant user$ ./main.py instock
        -- запускает проверку, синхронизирует kant.ru с таблицами 'instock_nagornaya', 'instock_timiryazevskaya',
    'instock_altufevo', 'instock_teply_stan'; рекомендуемая частота обновления:
        2- 4 раза в день, синхронизация сайта и бд: проверка разницы остатков товара по их размерам

    (env) laptop:kant user$ ./main.py products prices instock
    -- запускает проверку, синхронизирует kant.ru со всеми таблицами сразу

  * В ближайшее время добавится сериализатор выгрузки карточек товара (+ актуальной стоимости, + актуальные остатки)
для маркетплейсов, 'InSales' и 'МойСклад' (csv, json, xml).
На данный момент идет тестирование всех сериализаторов и основных рабочих шаблонов выгрузки популярных сервисов.

  * Актуальная версия доступна в 'main' git- ветке проекта.



Info: dkmarchuk@gmail.com
